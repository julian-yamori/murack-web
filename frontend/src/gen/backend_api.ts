/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * murack-web-backend
 * OpenAPI spec version: 0.1.0
 */
import useSwr from "swr";
import type { Arguments, Key, SWRConfiguration } from "swr";

import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import { customFetch } from "../custom_fetch.ts";
export interface CreateTagGroupRequest {
  description: string;
  name: string;
  order_index: number;
}

export type GroupListItemArtworkId = number | null;

/**
 * グループ選択画面のリスト要素
 */
export interface GroupListItem {
  artwork_id?: GroupListItemArtworkId;
  /** アーティスト名などの値 */
  name: string;
}

/**
 * アートワークの、リスト表示などに使用する縮小版画像データ
 */
export type MiniImage = number[];

export type NonEmptyString = string;

/**
 * 親プレイリストID
 */
export type PlaylistDetailsParentId = number | null;

/**
 * プレイリストの、プレイリスト一覧・曲一覧画面で利用する情報のみを抽出した詳細情報
 */
export interface PlaylistDetails {
  /** プレイリストID */
  id: number;
  /** プレイリスト名 */
  name: NonEmptyString;
  /** 親プレイリストID */
  parent_id?: PlaylistDetailsParentId;
  /** プレイリストの種類 */
  playlist_type: PlaylistType;
  /** DAPにこのプレイリストを保存するか */
  save_dap: boolean;
  /** ソートが降順か */
  sort_desc: boolean;
  /** ソート対象 */
  sort_type: SortTypeWithPlaylist;
}

/**
 * プレイリスト一覧画面のリスト要素
 */
export interface PlaylistListItem {
  /** プレイリストID */
  id: number;
  /** プレイリスト名 */
  name: NonEmptyString;
  /** プレイリストの種類 */
  playlist_type: PlaylistType;
}

/**
 * プレイリストの種類
 */
export type PlaylistType = typeof PlaylistType[keyof typeof PlaylistType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PlaylistType = {
  Normal: "Normal",
  Filter: "Filter",
  Folder: "Folder",
} as const;

/**
 * 曲のソートの種類

SortTypeWithPlaylist では SortType 定義を流用しているが、ToSchema 実装では文字列の配列を直接指定している。
SortType の種類を増やす際は注意！
 */
export type SortType = typeof SortType[keyof typeof SortType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SortType = {
  track_name: "track_name",
  artist: "artist",
  album: "album",
  genre: "genre",
  composer: "composer",
  duration: "duration",
  track_index: "track_index",
  disc_index: "disc_index",
  release_date: "release_date",
  rating: "rating",
  entry_date: "entry_date",
  path: "path",
} as const;

/**
 * 曲のソートの種類 (プレイリスト順付き)
 */
export type SortTypeWithPlaylist =
  typeof SortTypeWithPlaylist[keyof typeof SortTypeWithPlaylist];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SortTypeWithPlaylist = {
  playlist: "playlist",
  track_name: "track_name",
  artist: "artist",
  album: "album",
  genre: "genre",
  composer: "composer",
  duration: "duration",
  track_index: "track_index",
  disc_index: "disc_index",
  release_date: "release_date",
  rating: "rating",
  entry_date: "entry_date",
  path: "path",
} as const;

export interface TagGroup {
  created_at: string;
  description: string;
  id: number;
  name: string;
  order_index: number;
}

export type TrackListItemArtworkId = number | null;

/**
 * 曲リスト画面に返すリスト要素データ
 */
export interface TrackListItem {
  artwork_id?: TrackListItemArtworkId;
  /** 曲の ID */
  id: number;
  /** 曲名 */
  title: string;
}

export type UpdateTagGroupRequestDescription = string | null;

export type UpdateTagGroupRequestName = string | null;

export type UpdateTagGroupRequestOrderIndex = number | null;

export interface UpdateTagGroupRequest {
  description?: UpdateTagGroupRequestDescription;
  name?: UpdateTagGroupRequestName;
  order_index?: UpdateTagGroupRequestOrderIndex;
}

export type GetAlbumListParams = {
  artist?: string | null;
  album?: string | null;
  genre?: string | null;
};

export type GetArtistListParams = {
  artist?: string | null;
  album?: string | null;
  genre?: string | null;
};

export type GetGenreListParams = {
  artist?: string | null;
  album?: string | null;
  genre?: string | null;
};

export type GetTrackListParams = {
  artist?: string | null;
  album?: string | null;
  genre?: string | null;
  sort_type: SortType;
  sort_desc: boolean;
  /**
   * @minimum 0
   */
  limit?: number | null;
  /**
   * @minimum 0
   */
  offset?: number | null;
};

export type GetPlaylistListParams = {
  /**
   * 検索対象リストの親プレイリスト ID。指定しない場合は最上位のプレイリストのみを検索
   */
  parent_id?: number | null;
};

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary リスト用の mini サイズのアートワークを取得
 */
export type getMiniArtworkResponse200 = {
  data: MiniImage;
  status: 200;
};

export type getMiniArtworkResponse404 = {
  data: void;
  status: 404;
};

export type getMiniArtworkResponseComposite =
  | getMiniArtworkResponse200
  | getMiniArtworkResponse404;

export type getMiniArtworkResponse = getMiniArtworkResponseComposite & {
  headers: Headers;
};

export const getGetMiniArtworkUrl = (id: number) => {
  return `/api/artworks/${id}/mini`;
};

export const getMiniArtwork = async (
  id: number,
  options?: RequestInit,
): Promise<getMiniArtworkResponse> => {
  return customFetch<getMiniArtworkResponse>(getGetMiniArtworkUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetMiniArtworkKey = (id: number) =>
  [`/api/artworks/${id}/mini`] as const;

export type GetMiniArtworkQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMiniArtwork>>
>;
export type GetMiniArtworkQueryError = void;

/**
 * @summary リスト用の mini サイズのアートワークを取得
 */
export const useGetMiniArtwork = <TError = void>(
  id: number,
  options?: {
    swr?:
      & SWRConfiguration<Awaited<ReturnType<typeof getMiniArtwork>>, TError>
      & { swrKey?: Key; enabled?: boolean };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!id;
  const swrKey = swrOptions?.swrKey ??
    (() => isEnabled ? getGetMiniArtworkKey(id) : null);
  const swrFn = () => getMiniArtwork(id, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary グループ選択画面用にアルバムのリストを検索
 */
export type getAlbumListResponse200 = {
  data: GroupListItem[];
  status: 200;
};

export type getAlbumListResponseComposite = getAlbumListResponse200;

export type getAlbumListResponse = getAlbumListResponseComposite & {
  headers: Headers;
};

export const getGetAlbumListUrl = (params?: GetAlbumListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/group_list/album_list?${stringifiedParams}`
    : `/api/group_list/album_list`;
};

export const getAlbumList = async (
  params?: GetAlbumListParams,
  options?: RequestInit,
): Promise<getAlbumListResponse> => {
  return customFetch<getAlbumListResponse>(getGetAlbumListUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetAlbumListKey = (params?: GetAlbumListParams) =>
  [`/api/group_list/album_list`, ...(params ? [params] : [])] as const;

export type GetAlbumListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlbumList>>
>;
export type GetAlbumListQueryError = unknown;

/**
 * @summary グループ選択画面用にアルバムのリストを検索
 */
export const useGetAlbumList = <TError = unknown>(
  params?: GetAlbumListParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getAlbumList>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ??
    (() => isEnabled ? getGetAlbumListKey(params) : null);
  const swrFn = () => getAlbumList(params, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary グループ選択画面用にアーティストのリストを検索
 */
export type getArtistListResponse200 = {
  data: GroupListItem[];
  status: 200;
};

export type getArtistListResponseComposite = getArtistListResponse200;

export type getArtistListResponse = getArtistListResponseComposite & {
  headers: Headers;
};

export const getGetArtistListUrl = (params?: GetArtistListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/group_list/artist_list?${stringifiedParams}`
    : `/api/group_list/artist_list`;
};

export const getArtistList = async (
  params?: GetArtistListParams,
  options?: RequestInit,
): Promise<getArtistListResponse> => {
  return customFetch<getArtistListResponse>(getGetArtistListUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetArtistListKey = (params?: GetArtistListParams) =>
  [`/api/group_list/artist_list`, ...(params ? [params] : [])] as const;

export type GetArtistListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getArtistList>>
>;
export type GetArtistListQueryError = unknown;

/**
 * @summary グループ選択画面用にアーティストのリストを検索
 */
export const useGetArtistList = <TError = unknown>(
  params?: GetArtistListParams,
  options?: {
    swr?:
      & SWRConfiguration<Awaited<ReturnType<typeof getArtistList>>, TError>
      & { swrKey?: Key; enabled?: boolean };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ??
    (() => isEnabled ? getGetArtistListKey(params) : null);
  const swrFn = () => getArtistList(params, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary グループ選択画面用にジャンルのリストを検索
 */
export type getGenreListResponse200 = {
  data: GroupListItem[];
  status: 200;
};

export type getGenreListResponseComposite = getGenreListResponse200;

export type getGenreListResponse = getGenreListResponseComposite & {
  headers: Headers;
};

export const getGetGenreListUrl = (params?: GetGenreListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/group_list/genre_list?${stringifiedParams}`
    : `/api/group_list/genre_list`;
};

export const getGenreList = async (
  params?: GetGenreListParams,
  options?: RequestInit,
): Promise<getGenreListResponse> => {
  return customFetch<getGenreListResponse>(getGetGenreListUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetGenreListKey = (params?: GetGenreListParams) =>
  [`/api/group_list/genre_list`, ...(params ? [params] : [])] as const;

export type GetGenreListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGenreList>>
>;
export type GetGenreListQueryError = unknown;

/**
 * @summary グループ選択画面用にジャンルのリストを検索
 */
export const useGetGenreList = <TError = unknown>(
  params?: GetGenreListParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getGenreList>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ??
    (() => isEnabled ? getGetGenreListKey(params) : null);
  const swrFn = () => getGenreList(params, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary グループ選択に応じた曲リストを取得
 */
export type getTrackListResponse200 = {
  data: TrackListItem[];
  status: 200;
};

export type getTrackListResponseComposite = getTrackListResponse200;

export type getTrackListResponse = getTrackListResponseComposite & {
  headers: Headers;
};

export const getGetTrackListUrl = (params: GetTrackListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/group_list/track_list?${stringifiedParams}`
    : `/api/group_list/track_list`;
};

export const getTrackList = async (
  params: GetTrackListParams,
  options?: RequestInit,
): Promise<getTrackListResponse> => {
  return customFetch<getTrackListResponse>(getGetTrackListUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetTrackListKey = (params: GetTrackListParams) =>
  [`/api/group_list/track_list`, ...(params ? [params] : [])] as const;

export type GetTrackListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTrackList>>
>;
export type GetTrackListQueryError = unknown;

/**
 * @summary グループ選択に応じた曲リストを取得
 */
export const useGetTrackList = <TError = unknown>(
  params: GetTrackListParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getTrackList>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ??
    (() => isEnabled ? getGetTrackListKey(params) : null);
  const swrFn = () => getTrackList(params, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary プレイリスト一覧画面のためのリスト要素を取得
 */
export type getPlaylistListResponse200 = {
  data: PlaylistListItem[];
  status: 200;
};

export type getPlaylistListResponseComposite = getPlaylistListResponse200;

export type getPlaylistListResponse = getPlaylistListResponseComposite & {
  headers: Headers;
};

export const getGetPlaylistListUrl = (params?: GetPlaylistListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/playlists/list?${stringifiedParams}`
    : `/api/playlists/list`;
};

export const getPlaylistList = async (
  params?: GetPlaylistListParams,
  options?: RequestInit,
): Promise<getPlaylistListResponse> => {
  return customFetch<getPlaylistListResponse>(getGetPlaylistListUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetPlaylistListKey = (params?: GetPlaylistListParams) =>
  [`/api/playlists/list`, ...(params ? [params] : [])] as const;

export type GetPlaylistListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlaylistList>>
>;
export type GetPlaylistListQueryError = unknown;

/**
 * @summary プレイリスト一覧画面のためのリスト要素を取得
 */
export const useGetPlaylistList = <TError = unknown>(
  params?: GetPlaylistListParams,
  options?: {
    swr?:
      & SWRConfiguration<Awaited<ReturnType<typeof getPlaylistList>>, TError>
      & { swrKey?: Key; enabled?: boolean };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ??
    (() => isEnabled ? getGetPlaylistListKey(params) : null);
  const swrFn = () => getPlaylistList(params, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary プレイリスト一つの詳細情報を取得
 */
export type getPlaylistDetailsResponse200 = {
  data: PlaylistDetails;
  status: 200;
};

export type getPlaylistDetailsResponseComposite = getPlaylistDetailsResponse200;

export type getPlaylistDetailsResponse = getPlaylistDetailsResponseComposite & {
  headers: Headers;
};

export const getGetPlaylistDetailsUrl = (id: number) => {
  return `/api/playlists/${id}`;
};

export const getPlaylistDetails = async (
  id: number,
  options?: RequestInit,
): Promise<getPlaylistDetailsResponse> => {
  return customFetch<getPlaylistDetailsResponse>(getGetPlaylistDetailsUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetPlaylistDetailsKey = (id: number) =>
  [`/api/playlists/${id}`] as const;

export type GetPlaylistDetailsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlaylistDetails>>
>;
export type GetPlaylistDetailsQueryError = unknown;

/**
 * @summary プレイリスト一つの詳細情報を取得
 */
export const useGetPlaylistDetails = <TError = unknown>(
  id: number,
  options?: {
    swr?:
      & SWRConfiguration<Awaited<ReturnType<typeof getPlaylistDetails>>, TError>
      & { swrKey?: Key; enabled?: boolean };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!id;
  const swrKey = swrOptions?.swrKey ??
    (() => isEnabled ? getGetPlaylistDetailsKey(id) : null);
  const swrFn = () => getPlaylistDetails(id, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary プレイリストの曲リストを取得
 */
export type getPlaylistTracksResponse200 = {
  data: TrackListItem[];
  status: 200;
};

export type getPlaylistTracksResponseComposite = getPlaylistTracksResponse200;

export type getPlaylistTracksResponse = getPlaylistTracksResponseComposite & {
  headers: Headers;
};

export const getGetPlaylistTracksUrl = (id: number) => {
  return `/api/playlists/${id}/tracks`;
};

export const getPlaylistTracks = async (
  id: number,
  options?: RequestInit,
): Promise<getPlaylistTracksResponse> => {
  return customFetch<getPlaylistTracksResponse>(getGetPlaylistTracksUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetPlaylistTracksKey = (id: number) =>
  [`/api/playlists/${id}/tracks`] as const;

export type GetPlaylistTracksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlaylistTracks>>
>;
export type GetPlaylistTracksQueryError = unknown;

/**
 * @summary プレイリストの曲リストを取得
 */
export const useGetPlaylistTracks = <TError = unknown>(
  id: number,
  options?: {
    swr?:
      & SWRConfiguration<Awaited<ReturnType<typeof getPlaylistTracks>>, TError>
      & { swrKey?: Key; enabled?: boolean };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!id;
  const swrKey = swrOptions?.swrKey ??
    (() => isEnabled ? getGetPlaylistTracksKey(id) : null);
  const swrFn = () => getPlaylistTracks(id, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export type getTagGroupsResponse200 = {
  data: TagGroup[];
  status: 200;
};

export type getTagGroupsResponseComposite = getTagGroupsResponse200;

export type getTagGroupsResponse = getTagGroupsResponseComposite & {
  headers: Headers;
};

export const getGetTagGroupsUrl = () => {
  return `/api/tag_groups`;
};

export const getTagGroups = async (
  options?: RequestInit,
): Promise<getTagGroupsResponse> => {
  return customFetch<getTagGroupsResponse>(getGetTagGroupsUrl(), {
    ...options,
    method: "GET",
  });
};

export const getGetTagGroupsKey = () => [`/api/tag_groups`] as const;

export type GetTagGroupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTagGroups>>
>;
export type GetTagGroupsQueryError = unknown;

export const useGetTagGroups = <TError = unknown>(
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getTagGroups>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ??
    (() => isEnabled ? getGetTagGroupsKey() : null);
  const swrFn = () => getTagGroups(requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export type createTagGroupResponse200 = {
  data: TagGroup;
  status: 200;
};

export type createTagGroupResponseComposite = createTagGroupResponse200;

export type createTagGroupResponse = createTagGroupResponseComposite & {
  headers: Headers;
};

export const getCreateTagGroupUrl = () => {
  return `/api/tag_groups`;
};

export const createTagGroup = async (
  createTagGroupRequest: CreateTagGroupRequest,
  options?: RequestInit,
): Promise<createTagGroupResponse> => {
  return customFetch<createTagGroupResponse>(getCreateTagGroupUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(
      createTagGroupRequest,
    ),
  });
};

export const getCreateTagGroupMutationFetcher = (
  options?: SecondParameter<typeof customFetch>,
) => {
  return (
    _: Key,
    { arg }: { arg: CreateTagGroupRequest },
  ): Promise<createTagGroupResponse> => {
    return createTagGroup(arg, options);
  };
};
export const getCreateTagGroupMutationKey = () => [`/api/tag_groups`] as const;

export type CreateTagGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTagGroup>>
>;
export type CreateTagGroupMutationError = unknown;

export const useCreateTagGroup = <TError = unknown>(
  options?: {
    swr?:
      & SWRMutationConfiguration<
        Awaited<ReturnType<typeof createTagGroup>>,
        TError,
        Key,
        CreateTagGroupRequest,
        Awaited<ReturnType<typeof createTagGroup>>
      >
      & { swrKey?: string };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getCreateTagGroupMutationKey();
  const swrFn = getCreateTagGroupMutationFetcher(requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

export type updateTagGroupResponse200 = {
  data: TagGroup;
  status: 200;
};

export type updateTagGroupResponseComposite = updateTagGroupResponse200;

export type updateTagGroupResponse = updateTagGroupResponseComposite & {
  headers: Headers;
};

export const getUpdateTagGroupUrl = (id: number) => {
  return `/api/tag_groups/${id}`;
};

export const updateTagGroup = async (
  id: number,
  updateTagGroupRequest: UpdateTagGroupRequest,
  options?: RequestInit,
): Promise<updateTagGroupResponse> => {
  return customFetch<updateTagGroupResponse>(getUpdateTagGroupUrl(id), {
    ...options,
    method: "PUT",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(
      updateTagGroupRequest,
    ),
  });
};

export const getUpdateTagGroupMutationFetcher = (
  id: number,
  options?: SecondParameter<typeof customFetch>,
) => {
  return (
    _: Key,
    { arg }: { arg: UpdateTagGroupRequest },
  ): Promise<updateTagGroupResponse> => {
    return updateTagGroup(id, arg, options);
  };
};
export const getUpdateTagGroupMutationKey = (id: number) =>
  [`/api/tag_groups/${id}`] as const;

export type UpdateTagGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTagGroup>>
>;
export type UpdateTagGroupMutationError = unknown;

export const useUpdateTagGroup = <TError = unknown>(
  id: number,
  options?: {
    swr?:
      & SWRMutationConfiguration<
        Awaited<ReturnType<typeof updateTagGroup>>,
        TError,
        Key,
        UpdateTagGroupRequest,
        Awaited<ReturnType<typeof updateTagGroup>>
      >
      & { swrKey?: string };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getUpdateTagGroupMutationKey(id);
  const swrFn = getUpdateTagGroupMutationFetcher(id, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

export type deleteTagGroupResponse200 = {
  data: void;
  status: 200;
};

export type deleteTagGroupResponseComposite = deleteTagGroupResponse200;

export type deleteTagGroupResponse = deleteTagGroupResponseComposite & {
  headers: Headers;
};

export const getDeleteTagGroupUrl = (id: number) => {
  return `/api/tag_groups/${id}`;
};

export const deleteTagGroup = async (
  id: number,
  options?: RequestInit,
): Promise<deleteTagGroupResponse> => {
  return customFetch<deleteTagGroupResponse>(getDeleteTagGroupUrl(id), {
    ...options,
    method: "DELETE",
  });
};

export const getDeleteTagGroupMutationFetcher = (
  id: number,
  options?: SecondParameter<typeof customFetch>,
) => {
  return (_: Key, __: { arg: Arguments }): Promise<deleteTagGroupResponse> => {
    return deleteTagGroup(id, options);
  };
};
export const getDeleteTagGroupMutationKey = (id: number) =>
  [`/api/tag_groups/${id}`] as const;

export type DeleteTagGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTagGroup>>
>;
export type DeleteTagGroupMutationError = unknown;

export const useDeleteTagGroup = <TError = unknown>(
  id: number,
  options?: {
    swr?:
      & SWRMutationConfiguration<
        Awaited<ReturnType<typeof deleteTagGroup>>,
        TError,
        Key,
        Arguments,
        Awaited<ReturnType<typeof deleteTagGroup>>
      >
      & { swrKey?: string };
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getDeleteTagGroupMutationKey(id);
  const swrFn = getDeleteTagGroupMutationFetcher(id, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
